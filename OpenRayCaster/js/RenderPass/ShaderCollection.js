export var shaders = {point_data_vert:"_vr _hp _v4 projectedCoords _SC void main _LP  _RP  _LB projectedCoords =   projectionMatrix * modelViewMatrix * _v4 _LP  position, 1.0  _RP  _SC gl_Position= projectedCoords _SC  _RB  ",        
        point_data_frag:"\n #define COMPOSE_AVG 0 \n\n #define COMPOSE_MAX 1 \n\n #define COMPOSE_ONE 2 \n\n #define COMPOSE_GMA 3 \n\n #define COMPOSE_SUM 4 \n\n #define MIX_EARLY 0 \n\n #define MIX_LATE 1 \n\n #define INTERPOLATION_NEAR 0 \n\n #define INTERPOLATION_LINEAR 1 \n\n #define BOX_NONE 0 \n\n #define BOX_FILTER 1 \n\n #define BOX_MARK 2 \n\n #define BOX_BOTH 3 \n\n #define SURF_NONE 0 \n\n #define SURF_SRC 1 \n\n #define SURF_ISO 2 \n\n #define SURF_MARK 3 \n\n #ifndef DEPTH_SAMPLES \n\n #define DEPTH_SAMPLES 256 \n\n #endif \n_uf _hp _v3 sliceMax _SC _uf _hp _v3 sliceMin _SC _uf _hp sampler2D  frontFaceTex _SC _uf _hp sampler2D  backFaceTex _SC _uf _hp sampler2D  dataTex _SC _uf _hp sampler2D  colorTex _SC _uf _hp sampler2D  zIndexTex _SC _uf _hp _v4 po_ier _SC _uf _hp _f dampening _SC           _uf _hp _f rng_offset _SC  _uf _hp _v4 volumeDimensions _SC      _vr _hp _v4 projectedCoords _SC _c _i i_depth_samples = DEPTH_SAMPLES _SC   _c _hp _f f_depth_samples = _f _LP i_depth_samples _RP  _SC _hp _v4 z_offset _SC _hp _v3 backPos, frontPos, dir, deltaDirection _SC _hp _v2 texc _SC    _hp _f alphaFactor = 1.0 _SC _hp _f Dst = 0.0 _SC _hp _f Src = 0.0 _SC \n #if Z_INTERPOLATION == INTERPOLATION_LINEAR \n_hp _f  sampleP1 _SC _hp _f  sampleP2 _SC _hp _f z_distance _SC \n #endif \n\n #if BOX_MODE == BOX_FILTER || BOX_MODE == BOX_MARK  || BOX_MODE == BOX_BOTH  \n\n #define BOX_MODE_ON \n_uf _hp _f minBoxValue _SC _uf _hp _v4 box_mark_color _SC _uf _hp _f box_mark_opacity _SC _hp _f sampleB1 _SC _hp _f sampleB2 _SC _hp _f sampleB3 _SC _hp _f sampleB4 _SC _hp _f sampleB5 _SC _hp _f box _SC   bool mark=false _SC \n #endif \n\n #if SURF_MODE == SURF_SRC || SURF_MODE == SURF_ISO || SURF_MODE == SURF_MARK \n\n #define SURF_MODE_ON \n_uf _hp _v4 surface_color _SC _uf _hp _f minSurfValue _SC _uf _hp _f maxSurfValue _SC _uf _hp _f fogOpacity _SC _uf _hp _f depthShade _SC _hp _f surfDepth=-1.0 _SC _hp _f surfDst _SC _hp _f surfSrc _SC   \n #endif \n\n #ifdef AXIS_MARKERS \n_c _f axis_thickness = 0.003 _SC void draw_axis_markers _LP  _RP  _LB if   _LP  frontPos.x < axis_thickness && frontPos.y < axis_thickness  _RP   _LB _fc.r =0.5 _SC  _RB if  _LP backPos.x < axis_thickness &&  backPos.y < axis_thickness  _RP  _LB                   _fc.r+=  _LP 1.0 - _fc.a _RP  /2.0 _SC  _RB if   _LP  frontPos.z < axis_thickness && frontPos.x < axis_thickness  _RP  _LB _fc.g =0.5 _SC  _RB if  _LP  backPos.z < axis_thickness &&  backPos.x < axis_thickness  _RP  _LB     _fc.g+= _LP 1.0 - _fc.a _RP  /2.0 _SC  _RB if   _LP  frontPos.z < axis_thickness && frontPos.y < axis_thickness  _RP  _LB _fc.b=0.5 _SC  _RB if  _LP  backPos.z < axis_thickness &&  backPos.y < axis_thickness  _RP  _LB          _fc.b+= _LP 1.0 - _fc.a _RP  /2.0 _SC  _RB  _RB \n #endif \n_v4  colorLookup _LP _hp _f val _RP  _LB val =max _LP val - rng_offset, 0.0 _RP  /dampening _SC return texture2D _LP  colorTex, _v2 _LP 0.5, min _LP val , 0.9999 _RP  _RP   _RP  _SC  _RB bool inSlice _LP _v3 pos _RP  _LB return  all _LP lessThan _LP pos,sliceMax*volumeDimensions.xyz _RP  _RP  && all _LP greaterThan _LP pos,sliceMin*volumeDimensions.xyz _RP  _RP  _SC  _RB _hp _v4 candidate _SC _hp _f a _SC _hp _f half_a _SC _hp _f b _SC _hp _f c _SC _hp _f sp _SC _hp _f A _SC _hp _f po_iDistance _SC _hp _v2 dTexC _SC void  marchray _LP _hp _v3 startPos, _hp _v3 endPos _RP  _LB a= distance _LP startPos.xyz,endPos.xyz _RP  _SC half_a = a/2.0 _SC for _LP _i y = 0 _SC  y < 64 _SC  y++ _RP  _LB dTexC.y=_f _LP y _RP /64.0 _SC for _LP _i x = 0 _SC  x < 64 _SC  x++ _RP  _LB dTexC.x=_f _LP x _RP /64.0 _SC candidate= texture2D _LP  dataTex,dTexC _RP  _SC b= distance _LP endPos.xyz,candidate.xyz _RP  _SC c= distance _LP candidate.xyz,startPos.xyz _RP  _SC sp=  _LP a+b+c _RP /2.0 _SC A= sqrt _LP   sp* _LP sp-a _RP * _LP sp-b _RP * _LP sp-c _RP  _RP  _SC po_iDistance=A/half_a _SC if  _LP  po_iDistance < candidate.a /128.0 _RP  _LB Src= mix _LP candidate.a,candidate.a/2.0,po_iDistance*10.0 _RP  _SC \n #if COMPOSE == COMPOSE_MAX          \nDst = max _LP Dst, Src _RP  _SC \n #elif  COMPOSE == COMPOSE_AVG ||  COMPOSE == COMPOSE_SUM \nDst+=Src _SC \n #elif COMPOSE == COMPOSE_ONE \nDst +=  _LP  1.0 - Dst  _RP  * Src *  _LP alphaFactor/ f_depth_samples _RP  _SC     \n #elif COMPOSE == COMPOSE_GMA \nDst += Src / f_depth_samples - pow _LP Src,alphaFactor _RP  / f_depth_samples _SC        \n #endif   \nbreak _SC  _RB  _RB    if  _LP  po_iDistance < candidate.a /128.0 _RP  _LB break _SC  _RB  _RB \n #if  COMPOSE == COMPOSE_SUM  \nDst = Dst /  _LP 1.0/distance _LP backPos , frontPos _RP  _RP  _SC \n #elif COMPOSE == COMPOSE_AVG \nDst =  _LP Dst _RP  /  _LP 1.0/distance _LP backPos , frontPos _RP  _RP  _SC \n #endif  \n_fc = colorLookup _LP Dst _RP  _SC  _RB void main _LP  void  _RP   _LB texc= _v2 _LP  _LP  _LP projectedCoords.x / projectedCoords.w _RP  + 1.0  _RP  / 2.0,  _LP  _LP projectedCoords.y / projectedCoords.w _RP  + 1.0  _RP  / 2.0  _RP  _SC frontPos = texture2D _LP frontFaceTex, texc _RP .xyz _SC backPos = texture2D _LP backFaceTex, texc _RP .xyz _SC deltaDirection =  _LP backPos - frontPos _RP  / f_depth_samples _SC marchray _LP frontPos.xyz , backPos.xyz  _RP  _SC    \n #ifdef AXIS_MARKERS \ndraw_axis_markers _LP  _RP  _SC \n #endif   \n\n #if BOX_MODE == BOX_MARK || BOX_MODE == BOX_BOTH   \nif  _LP mark _RP   _LB  _fc =mix _LP _fc, box_mark_color,  box_mark_opacity  _RP  _SC  _RB \n #endif \nif  _LP  abs _LP texc.x-po_ier.x _RP  < 0.001 && abs _LP texc.y-po_ier.y _RP  < 0.02 _RP  _LB _fc.rgb= _v3 _LP 0.2,0.6,0.4 _RP  _SC  _RB if  _LP  abs _LP texc.x-po_ier.x _RP  < 0.02 && abs _LP texc.y-po_ier.y _RP  < 0.001 _RP  _LB _fc.rgb= _v3 _LP 0.2,0.6,0.4 _RP  _SC  _RB  _RB  ",        
        point_project_vert:"_vr _v3 volumeDataCoord _SC void main _LP  _RP  _LB volumeDataCoord = normal _SC gl_Position = projectionMatrix * modelViewMatrix * _v4 _LP  position, 1.0  _RP  _SC  _RB  ",        
        point_project_frag:"_vr _v3 volumeDataCoord _SC void main _LP  _RP  _LB _fc = _v4 _LP  volumeDataCoord.x , volumeDataCoord.y, volumeDataCoord.z, 1.0  _RP  _SC  _RB  ",        
        vol_data_vert:"_vr _hp _v4 projectedCoords _SC void main _LP  _RP  _LB projectedCoords =   projectionMatrix * modelViewMatrix * _v4 _LP  position, 1.0  _RP  _SC gl_Position= projectedCoords _SC  _RB  ",        
        vol_data_frag:"\n #define COMPOSE_AVG 0 \n\n #define COMPOSE_MAX 1 \n\n #define COMPOSE_ONE 2 \n\n #define COMPOSE_GMA 3 \n\n #define COMPOSE_SUM 4 \n\n #define MIX_EARLY 0 \n\n #define MIX_LATE 1 \n\n #define INTERPOLATION_NEAR 0 \n\n #define INTERPOLATION_LINEAR_SLOW 1 \n\n #define INTERPOLATION_LINEAR_FAST 2 \n\n #define BOX_NONE 0 \n\n #define BOX_FILTER 1 \n\n #define BOX_MARK 2 \n\n #define BOX_BOTH 3 \n\n #define SURF_NONE 0 \n\n #define SURF_SRC 1 \n\n #define SURF_ISO 2 \n\n #define SURF_MARK 3 \n\n #define A 0 \n\n #define B 3 \n\n #ifndef DEPTH_SAMPLES \n\n #define DEPTH_SAMPLES 256 \n\n #endif \n_uf _hp _v3 sliceMax _SC _uf _hp _v3 sliceMin _SC _uf _hp sampler2D  frontFaceTex _SC _uf _hp sampler2D  backFaceTex _SC _uf _hp sampler2D  dataTex _SC _uf _hp sampler2D  colorTex _SC _uf _hp sampler2D  zIndexTex _SC _uf _hp _v4 po_ier _SC _uf _hp _f dampening _SC           _uf _hp _f rng_offset _SC  _uf _hp _v4 volumeDimensions _SC      _vr _hp _v4 projectedCoords _SC _c _i i_depth_samples = DEPTH_SAMPLES _SC   _c _hp _f f_depth_samples = _f _LP i_depth_samples _RP  _SC _hp _v4 z_offset _SC _hp _v3 backPos, frontPos, dir, deltaDirection _SC _hp _v2 texc _SC    _hp _v2 z_offset_texel = _v2 _LP 0.0,0.5 _RP  _SC _hp _v2 cmap_offset_texel = _v2 _LP 0.5,0.0 _RP  _SC _hp _f alphaFactor = 1.0 _SC _hp _f Dst = 0.0 _SC _hp _f Src = 0.0 _SC \n #if Z_INTERPOLATION == INTERPOLATION_LINEAR_SLOW || Z_INTERPOLATION == INTERPOLATION_LINEAR_FAST \n_hp _f  sampleP1 _SC _hp _f  sampleP2 _SC _hp _v4 sampleP _SC _hp _f z_distance _SC \n #endif \n\n #if BOX_MODE == BOX_FILTER || BOX_MODE == BOX_MARK  || BOX_MODE == BOX_BOTH  \n\n #define BOX_MODE_ON \n_uf _hp _f minBoxValue _SC _uf _hp _v4 box_mark_color _SC _uf _hp _f box_mark_opacity _SC _hp _f sampleB1 _SC _hp _f sampleB2 _SC _hp _f sampleB3 _SC _hp _f sampleB4 _SC _hp _f sampleB5 _SC _hp _v2 offsetB1 = _v2 _LP -volumeDimensions.x ,0.0 _RP  _SC _hp _v2 offsetB2 = _v2 _LP 0.0 ,-volumeDimensions.y _RP  _SC _hp _v2 offsetB3 = _v2 _LP volumeDimensions.x , 0.0 _RP  _SC _hp _v2 offsetB4 = _v2 _LP 0.0 , volumeDimensions.y _RP  _SC _hp _f box _SC   bool mark=false _SC \n #endif \n\n #if SURF_MODE == SURF_SRC || SURF_MODE == SURF_ISO || SURF_MODE == SURF_MARK \n\n #define SURF_MODE_ON \n_uf _hp _v4 surface_color _SC _uf _hp _f minSurfValue _SC _uf _hp _f maxSurfValue _SC _uf _hp _f fogOpacity _SC _uf _hp _f depthShade _SC _hp _f surfDepth=-1.0 _SC _hp _f surfDst _SC _hp _f surfSrc _SC   \n #endif \n\n #ifdef AXIS_MARKERS \n_c _f axis_thickness = 0.003 _SC void draw_axis_markers _LP  _RP  _LB if   _LP  frontPos.x < axis_thickness && frontPos.y < axis_thickness  _RP   _LB _fc.r =0.5 _SC  _RB if  _LP backPos.x < axis_thickness &&  backPos.y < axis_thickness  _RP  _LB                   _fc.r+=  _LP 1.0 - _fc.a _RP  /2.0 _SC  _RB if   _LP  frontPos.z < axis_thickness && frontPos.x < axis_thickness  _RP  _LB _fc.g =0.5 _SC  _RB if  _LP  backPos.z < axis_thickness &&  backPos.x < axis_thickness  _RP  _LB     _fc.g+= _LP 1.0 - _fc.a _RP  /2.0 _SC  _RB if   _LP  frontPos.z < axis_thickness && frontPos.y < axis_thickness  _RP  _LB _fc.b=0.5 _SC  _RB if  _LP  backPos.z < axis_thickness &&  backPos.y < axis_thickness  _RP  _LB          _fc.b+= _LP 1.0 - _fc.a _RP  /2.0 _SC  _RB  _RB \n #endif \n_v4  colorLookup _LP _hp _f val _RP  _LB val =max _LP val - rng_offset, 0.0 _RP  /dampening _SC cmap_offset_texel.t= min _LP val , 0.9999 _RP  _SC return texture2D _LP  colorTex, cmap_offset_texel  _RP  _SC  _RB bool inSlice _LP _v3 pos _RP  _LB return  all _LP lessThan _LP pos,sliceMax*volumeDimensions.xyz _RP  _RP  && all _LP greaterThan _LP pos,sliceMin*volumeDimensions.xyz _RP  _RP  _SC  _RB void  marchray _LP _hp _v3 currentPosition, _hp _v3 deltaDirection _RP  _LB for _LP _i i = 0 _SC  i < i_depth_samples _SC  i++ _RP  _LB if  _LP inSlice _LP currentPosition _RP  _RP  _LB \n #if Z_INTERPOLATION == INTERPOLATION_LINEAR_SLOW \nz_offset_texel.s=floor _LP currentPosition.z * volumeDimensions.w  _RP /volumeDimensions.w  _SC z_offset= texture2D _LP  zIndexTex, z_offset_texel  _RP  _SC  sampleP1 = texture2D _LP  dataTex, currentPosition.xy + z_offset.st  _RP .a _SC sampleP2 = texture2D _LP  dataTex, currentPosition.xy + z_offset.pq  _RP .a _SC z_distance =fract _LP currentPosition.z * volumeDimensions.w   _RP  _SC Src= mix _LP sampleP1, sampleP2, z_distance _RP  _SC   \n #elif Z_INTERPOLATION == INTERPOLATION_LINEAR_FAST \nz_offset_texel.s=floor _LP currentPosition.z * volumeDimensions.w  _RP /volumeDimensions.w  _SC z_offset= texture2D _LP  zIndexTex, z_offset_texel  _RP  _SC  sampleP = texture2D _LP  dataTex, currentPosition.xy + z_offset.st  _RP  _SC z_distance =fract _LP currentPosition.z * volumeDimensions.w   _RP  _SC Src= mix _LP sampleP[A], sampleP[B], z_distance _RP  _SC \n #else   \nz_offset_texel.s=currentPosition.z _SC z_offset= texture2D _LP  zIndexTex,z_offset_texel  _RP  _SC  Src = texture2D _LP  dataTex, currentPosition.xy + z_offset.st _RP .a _SC \n #endif \n\n #ifdef BOX_MODE_ON \nsampleB1 = texture2D _LP  dataTex, currentPosition.xy + offsetB1 + z_offset.st  _RP .a _SC sampleB2 = texture2D _LP  dataTex, currentPosition.xy + offsetB2 + z_offset.st  _RP .a _SC sampleB3 = texture2D _LP  dataTex, currentPosition.xy + offsetB3 + z_offset.st  _RP .a _SC sampleB4 = texture2D _LP  dataTex, currentPosition.xy + offsetB4 + z_offset.st  _RP .a _SC  sampleB5 = texture2D _LP  dataTex, currentPosition.xy + z_offset.pq  _RP .a _SC box = Src + sampleB1 + sampleB2 + sampleB3 + sampleB4 + sampleB5 _SC \n #if BOX_MODE == BOX_MARK || BOX_MODE == BOX_BOTH  \nif  _LP box  > minBoxValue && Src > minBoxValue * 2.0 _RP  _LB mark=true _SC  _RB \n #endif \n\n #if BOX_MODE == BOX_FILTER || BOX_MODE == BOX_BOTH  \nif  _LP box  < minBoxValue || Src < minBoxValue * 2.0 _RP  _LB Src=0.0 _SC  _RB \n #endif \n\n #endif \n\n #ifdef SURF_MODE_ON \nif  _LP Src >  minSurfValue  && Src < maxSurfValue  _RP   _LB  if  _LP  surfDepth == -1.0 _RP  _LB \n #if SURF_MODE == SURF_SRC  \nsurfSrc=Src _SC \n #elif SURF_MODE == SURF_ISO \nsurfSrc=minSurfValue _SC \n #endif  \nsurfDepth = _f _LP  i  _RP  / f_depth_samples _SC  surfDst=Dst _SC break _SC                       _RB  _RB \n #endif \n\n #if MIX == MIX_EARLY             \n\n #if COMPOSE == COMPOSE_MAX          \nDst = max _LP Dst, Src _RP  _SC _fc = colorLookup _LP Dst  _RP  _SC \n #elif  COMPOSE == COMPOSE_AVG  \nSrc=Src/f_depth_samples _SC _fc += colorLookup _LP Src  _RP  _SC \n #elif COMPOSE == COMPOSE_ONE \nSrc =  _LP  1.0 - Dst  _RP  * Src * alphaFactor _SC  Dst+=Src _SC _fc += colorLookup _LP Src  _RP  _SC \n #elif COMPOSE == COMPOSE_GMA \nSrc= Src  - pow _LP Src,alphaFactor _RP  _SC            _fc += colorLookup _LP Src  _RP  _SC \n #endif \n\n #else   \n\n #if COMPOSE == COMPOSE_MAX          \nDst = max _LP Dst, Src _RP  _SC \n #elif  COMPOSE == COMPOSE_AVG ||  COMPOSE == COMPOSE_SUM \nDst+=Src _SC \n #elif COMPOSE == COMPOSE_ONE \nDst +=  _LP  1.0 - Dst  _RP  * Src *  _LP alphaFactor/ f_depth_samples _RP  _SC     \n #elif COMPOSE == COMPOSE_GMA \nDst += Src / f_depth_samples - pow _LP Src,alphaFactor _RP  / f_depth_samples _SC        \n #endif \n\n #endif \n\n #ifdef BREAK_ON_MAX_DST \nif  _LP Dst >  0.999 _RP   _LB  break _SC  _RB \n #endif \n _RB   currentPosition += deltaDirection _SC  _RB \n #ifdef SURF_MODE_ON \n\n #if  COMPOSE == COMPOSE_SUM  \nDst = Dst /  _LP 1.0/distance _LP backPos , frontPos _RP  _RP  _SC \n #elif COMPOSE == COMPOSE_AVG \nDst =  _LP Dst/f_depth_samples _RP  /  _LP 1.0/distance _LP backPos , frontPos _RP  _RP  _SC \n #endif  \nif  _LP surfDepth == -1.0 _RP  _LB _f depthDampening=  _LP 1.0 + depthShade/2.0 _RP   -  depthShade _SC _v4 BackFogColor = colorLookup _LP Dst _RP  * fogOpacity * depthDampening _SC _fc.rgba =  BackFogColor.rgba  _SC  _RB else _LB  _f depthDampening= mix _LP  _LP 1.0 + depthShade/2.0 _RP  ,  _LP 1.0 - depthShade/2.0 _RP  ,  surfDepth _RP   _SC \n #if SURF_MODE == SURF_MARK  \n_v4 surfaceColor = surface_color _SC \n #else \n_v4 surfaceColor = colorLookup _LP surfSrc _RP  _SC \n #endif \n_v4 FrontFogColor = colorLookup _LP surfDst _RP * fogOpacity * depthDampening _SC _v4 depth_shaded_surfaceColor = surfaceColor.rgba * depthDampening _SC _v3 depth_shaded_surfaceColorPlusFog = depth_shaded_surfaceColor.rgb + FrontFogColor.rgb * fogOpacity _SC _fc.rgb = depth_shaded_surfaceColorPlusFog.rgb _SC _fc.a=1.0 _SC  _RB \n #elif MIX == MIX_LATE \n\n #if  COMPOSE == COMPOSE_SUM  \nDst = Dst /  _LP 1.0/distance _LP backPos , frontPos _RP  _RP  _SC \n #elif COMPOSE == COMPOSE_AVG \nDst =  _LP Dst/f_depth_samples _RP  /  _LP 1.0/distance _LP backPos , frontPos _RP  _RP  _SC \n #endif  \n_fc = colorLookup _LP Dst _RP  _SC \n #endif \n _RB void main _LP  void  _RP   _LB texc= _v2 _LP  _LP  _LP projectedCoords.x / projectedCoords.w _RP  + 1.0  _RP  / 2.0,  _LP  _LP projectedCoords.y / projectedCoords.w _RP  + 1.0  _RP  / 2.0  _RP  _SC frontPos = texture2D _LP frontFaceTex, texc _RP .xyz _SC backPos = texture2D _LP backFaceTex, texc _RP .xyz _SC deltaDirection =  _LP backPos - frontPos _RP  / f_depth_samples _SC marchray _LP frontPos.xyz * volumeDimensions.xyz, deltaDirection.xyz * volumeDimensions.xyz _RP  _SC    \n #ifdef AXIS_MARKERS \ndraw_axis_markers _LP  _RP  _SC \n #endif   \n\n #if BOX_MODE == BOX_MARK || BOX_MODE == BOX_BOTH   \nif  _LP mark _RP   _LB  _fc =mix _LP _fc, box_mark_color,  box_mark_opacity  _RP  _SC  _RB \n #endif \nif  _LP  abs _LP texc.x-po_ier.x _RP  < 0.001 && abs _LP texc.y-po_ier.y _RP  < 0.02 _RP  _LB _fc.rgb= _v3 _LP 0.2,0.6,0.4 _RP  _SC  _RB if  _LP  abs _LP texc.x-po_ier.x _RP  < 0.02 && abs _LP texc.y-po_ier.y _RP  < 0.001 _RP  _LB _fc.rgb= _v3 _LP 0.2,0.6,0.4 _RP  _SC  _RB  _RB  ",        
        vol_egress_vert:"_vr _v3 volumeDataCoord _SC void main _LP  _RP  _LB volumeDataCoord = normal _SC gl_Position = projectionMatrix * modelViewMatrix * _v4 _LP  position, 1.0  _RP  _SC  _RB  ",        
        vol_egress_frag:"_vr _v3 volumeDataCoord _SC void main _LP  _RP  _LB _fc = _v4 _LP  volumeDataCoord.x , volumeDataCoord.y, volumeDataCoord.z, 1.0  _RP  _SC  _RB  ",        
        vol_ingress_vert:"_vr _v3 volumeDataCoord _SC void main _LP  _RP  _LB volumeDataCoord = normal _SC gl_Position = projectionMatrix * modelViewMatrix * _v4 _LP  position, 1.0  _RP  _SC  _RB  ",        
        vol_ingress_frag:"_vr _v3 volumeDataCoord _SC void main _LP  _RP  _LB _fc = _v4 _LP  volumeDataCoord.x , volumeDataCoord.y, volumeDataCoord.z, 1.0  _RP  _SC  _RB  ",        
        };
 export var __transmograf = 
        "#define _c const \n #define _fc gl_FragColor \n#define _vr varying \n #define _uf uniform \n #define _hp highp\n #define _v2 vec2\n #define _v3 vec3\n #define _v4 vec4\n #define _f float\n #define _i int\n #define _SC ;\n #define _LB {\n #define _RB }\n #define _LP (\n #define _RP )\n #define _FL for \n";
        