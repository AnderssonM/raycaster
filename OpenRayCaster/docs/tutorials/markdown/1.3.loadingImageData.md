
Loading an Image Data File.
---------------


In the previous examples an Open RayCaster (ORC) volume was created, but since no data
was loaded, only a set of axes are displayed. This chapter describes one of 
the methods of loading data into ORC, using the nativeImageData loader.
  
1. **The setup**

    The setup is the same as for the previous examples.

        <script src="js/lib.depend.js" >  </script>
        <script src="js/OpenRayCaster.js" >  </script>
        <script>
            var canvas_element = document.getElementById("rayCanvas");
            rayCaster = new OpenRayCaster({renderTarget:canvas_element});
        </script>   
         

2. **Loading an image data file**
    
    ORC supports a number of different data format. One method of loading data
    is to use an image file with all the slices compiled into a single texture.
    With the volume slices laid out in order from left to right, and top to 
    bottom, as illustrated below.

    <img style="margin-right:25px;width:550px" src="debuglogo.4x8.png"></img>
   
    Then we load the data file by using the loadDataFile method. ORC will 
    determine from the file type extension that this is an image file and 
    automatically use the nativeImageData loader.

    The nativeImage loader also needs to know how many sub images (rows and columns)
    are in the image data file. This information is picked up from the .4x8. part
    of the file name. It is thus required to add this section of .[rows]x[cols].
    to the file name just before the extension. 

        <script>
            rayCaster.loadDataFile(root+'/sampleData/logo2.4x8.png');
        </script>
 	
    This method supports any of the native image formats supported by
    the browser (PNG,GIF,JPEG etc. depending on browser).
    
    *Note:*  While this is a very easy method to get started with. It is 
    important to understand the effect each image format might have on the 
    raw data (e.g destructive compression in the jpeg format).
    Also note that this method is limited in that it only uses one color channel
    (red) to obtain its data, and since each channel of the JS image data object
    is limited to 8bit, _this will effectively normalize your value 
    range to 256 levels between 0.0-1.0._


3. **Optional callback**
    
    The data loading process is asynchronous, which means the loadDataFile call
    will return directly. The loadDataFile method also takes an optional 'callBack'
    argument that can be used for receiving notification when the load is complete.


        <script>
            function loadCompleteCallback(){
                console.log("Data loaded");
            }
            rayCaster.loadDataFile(root+'/sampleData/logo2.4x8.png',loadCompleteCallback);
        </script>
<canvas id="rayCanvas" height="400" width="670" ></canvas>

    ***Full code for this exercise.*** 

        <!DOCTYPE html> 
        <html> 
        <body> 
            <script src="js/lib.depend.js" >  </script>
            <script src="js/OpenRayCaster.js" >  </script>
            <script>
                var canvas_element = document.getElementById("rayCanvas");
                rayCaster = new OpenRayCaster({renderTarget:canvas_element});
                function loadCompleteCallback(){
                    console.log("Data loaded");
                }
                rayCaster.loadDataFile(root+'/sampleData/logo2.4x8.png',loadCompleteCallback);
            </script>   
        </body> 
        </html> 


<script id="tutorialScript">
    (function(){
	var canvas_element = document.getElementById("rayCanvas");
	var rayCaster = new OpenRayCaster({renderTarget:canvas_element});
	function loadCompleteCallback(){
	    console.log("Data loaded");
	}
	rayCaster.loadDataFile(root+'/sampleData/logo2.4x8.png',loadCompleteCallback);	
    })();

    
    
</script>
