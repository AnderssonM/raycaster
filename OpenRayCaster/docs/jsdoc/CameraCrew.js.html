<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: CameraCrew.js</title>
    
    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">
    
    <h1 class="page-title">Source: CameraCrew.js</h1>
    
    


    
    <section>
        <article>
            <pre class="prettyprint source"><code>/* global THREE */

/**
 * RayCaster
 * A web based program for ray traced rendering of volumetric data.
 * @author Martin Andersson, V.I.C, 2015. All rights reserved
 *                
 */
from(js_lib).import("OrbitControls.js", "TrackballControls.js");

/**
 * CameraCrew class, a collection of cameras and camera controls
 * @author Martin Andersson, V.I.C, 2015. All rights reserved
 * @constructor
 * @param {Object} options A raycaster options object
 * @param {Element} target The target canvas 
 * @param {Integer} [FPS=60]  Max Frames Per Seconds
 * @param {Integer} [DPSANIM=256] Number of depth samples to use during animation.
 */
function CameraCrew(rayCaster, FPS, DPSANIM) {
    this.FPS = FPS || 60;
    console.log("FPS:",rayCaster,this.FPS);
    
    this.DPSANIM = DPSANIM || 256;
    this.lastRender = 0;
    this.lastZoom = 0;
    this.oRange = 0.865;
    this.oOffsetX = 0;
    this.oOffsetY = 0;
    this.rx = 1;
    this.ry = 1;
    /** @type{Object} **/
    this.afRequest = -1;
    this.rayCaster = rayCaster;
    this.render = rayCaster.render.bind(rayCaster);
    this.aspect = 1.0;
    this.target = rayCaster.renderTarget;
    this.settings = rayCaster.settings;
    this.renderer = rayCaster.renderer;

    this.cameras = this.setupCameraCollection();

    this.settings['camera'] = this.camera = this.cameras[CameraCrew.PRESPECTIVE];
//    this.initTrackballControls();
    this.controls = new THREE.OrbitControls(this.cameras[CameraCrew.PRESPECTIVE], this.target);
    this.selectCamera(CameraCrew.PRESPECTIVE);
    rayCaster.camera = this.camera;
}

CameraCrew.ORTHO_CAM_X = 0;
CameraCrew.ORTHO_CAM_Y = 1;
CameraCrew.ORTHO_CAM_Z = 2;
CameraCrew.ORTHOGRAPHIC = 3;
CameraCrew.PRESPECTIVE = 4;

CameraCrew.prototype.setupCameraCollection = function () {
    var cameras = {};
    
    //ORTHO_CAM_X Setup
    var ocx = new THREE.OrthographicCamera(1.2 / -2, 1.2 / 2, 1.2 / 2, 1.2 / -2, -10, 10);
    ocx.position.x = 2.0;
    ocx.up = new THREE.Vector3(0, 0, 1);
    ocx.lookAt(new THREE.Vector3(0, 0, 0));
    cameras[CameraCrew.ORTHO_CAM_X] = ocx;

    //ORTHO_CAM_Y Setup
    var ocy = new THREE.OrthographicCamera(1.2 / -2, 1.2 / 2, 1.2 / 2, 1.2 / -2, -10, 10);
    ocy.position.y = 2.0;
    ocy.up = new THREE.Vector3(1, 0, 0);
    ocy.lookAt(new THREE.Vector3(0, 0, 0));
    cameras[CameraCrew.ORTHO_CAM_Y] = ocy;
    
    //ORTHO_CAM_Z Setup
    var ocz = new THREE.OrthographicCamera(1.2 / -2, 1.2 / 2, 1.2 / 2, 1.2 / -2, -10, 10);
    ocz.position.z = 2.0;
    ocz.up = new THREE.Vector3(0, 1, 0);
    ocz.lookAt(new THREE.Vector3(0, 0, 0));
    cameras[CameraCrew.ORTHO_CAM_Z]=ocz;
    
    //ORTHOGRPAHIC Cam Setup
    var oc = new THREE.OrthographicCamera(1.2 / -2, 1.2 / 2, 1.2 / 2, 1.2 / -2, -10, 10);
    oc.position.z = 2.0;
    oc.up = new THREE.Vector3(0, 1, 0);
    oc.lookAt(new THREE.Vector3(0, 0, 0));
    cameras[CameraCrew.ORTHOGRAPHIC]=oc;
    
    //PERSPECTIVE Cam setup
    var pc = this.pCam = new THREE.PerspectiveCamera(40, 1 / 1, 0.01, 3000.0);
    pc.position.z = 2.0;
    pc.lookAt(new THREE.Vector3(0, 0, 0));
    cameras[CameraCrew.PRESPECTIVE]=pc;
    
    return cameras;
};
/**
 * selectCamera, selects the active camera
 * @param {string} cameraType  Can be any of the following:&lt;br>
 *                              |'oCamX': Orthographic locked view along X axis&lt;br> 
 *                              |this.ORTHO_CAM_Y: Orthographic locked view along Y axis&lt;br> 
 *                              |this.ORTHO_CAM_Z: Orthographic locked view along Z axis&lt;br> 
 *                              |CameraCrew.ORTHOGRAPHIC : Orthographic unlocked view&lt;br> 
 *                              |CameraCrew.PRESPECTIVE : Perspective  unlocked view&lt;br>
 * @returns {undefined}
 */
CameraCrew.prototype.selectCamera = function (cameraType) {
    console.log("selectCamera", cameraType);
    this.settings['camera'] = this.camera = this.cameras[cameraType];
    if (cameraType === CameraCrew.ORTHOGRAPHIC || cameraType === CameraCrew.PRESPECTIVE) {
        this.controls.object = this.camera;
    }
    this.controls.reset();
    this.camera.lookAt(new THREE.Vector3(0, 0, 0));
//    this.controls.center.set(0.0, 0.0, 0.0);
    this.cameraType = cameraType;
    this.setSize(this.target.clientWidth, this.target.clientHeight, this.rx, this.ry);

};
/**
 * setSize, sets the size and aspect of the camera frustum
 * @param {type} w , width of camera frustum in pixels
 * @param {type} h , height of camera frustum in pixels
 * @param {type} [rx=1] , render resolution
 * @param {type} [ry=1] , render resolution
 * @returns {undefined}
 */
CameraCrew.prototype.setSize = function (w, h, rx, ry) {
    console.log("CameraCrew:setSize", w, h, this.cameraType);
    this.aspect = w / h;
    this.w = w;
    this.h = h;
    this.rx = rx || 1;
    this.ry = ry || 1;
    this.renderer.setSize(this.w / this.rx, this.h / this.ry);
    if (this.cameraType === CameraCrew.PRESPECTIVE) {
        this.camera['aspect'] = this.aspect;
    }
    else {
        if (w >= h) {
            this.camera['top'] = this.oRange + this.oOffsetY;
            this.camera['bottom'] = -this.oRange + this.oOffsetY;
            this.camera['left'] = -this.oRange * this.aspect + this.oOffsetX;
            this.camera['right'] = this.oRange * this.aspect + this.oOffsetX;
        }
        else {
            this.camera['top'] = this.oRange / this.aspect + this.oOffsetY;
            this.camera['bottom'] = -this.oRange / this.aspect + this.oOffsetY;
            this.camera['left'] = -this.oRange + this.oOffsetX;
            this.camera['right'] = this.oRange + this.oOffsetX;
        }
    }

    this.camera.updateProjectionMatrix();
};

/**
 * initTrackballControls, use trackball style controls
 * @this{CameraCrew}
 * @returns {undefined}
 */
CameraCrew.prototype.initTrackballControls = function () {
    this.controls = new THREE.TrackballControls(this.camera, this.target);
    this.controls.rotateSpeed = 1.0;
    this.controls.zoomSpeed = 1.2;
    this.controls.panSpeed = 0.8;

    this.controls.noZoom = false;
    this.controls.noPan = false;
    this.controls.staticMoving = true;
    this.controls.dynamicDampingFactor = 0.3;

};
/**
 * initOrbitControls, use orbit style controls
 * @this{CameraCrew}
 * @returns {undefined}
 */
CameraCrew.prototype.initOrbitControls = function () {
    this.controls = new THREE.OrbitControls(this.camera, this.target);
    this.controls.center.set(0.0, 0.0, 0.0);
};

/**
 * selectControls, select the type of controls to use
 * @this {CameraCrew}
 * @param {string} controlType The type of controls to use ['orbit'|'trackball']
 * @returns {undefined}
 * 
 */
CameraCrew.prototype.selectControls = function (controlType) {
    if (controlType === 'orbit' || controlType === 'orb') {
        this.initOrbitControls();
    } else {
        this.initTrackballControls();
    }
};
/**
 * setupMouseEvents, set up mouse event listeners.
 * @returns {undefined}
 */
CameraCrew.prototype.setupMouseEvents = function () {
    this.target.onmouseout = this.stopAnimation.bind(this);
    this.target.onmouseup = this.stopAnimation.bind(this);
    this.target.onmousedown = this.startAnimation.bind(this);
    this.target.onmousemove = this.onMouseMove.bind(this);
    this.target.onclick = this.onMouseClick.bind(this);
//    this.target.addEventListener('DOMMouseScroll', this.onZoom.bind(this), false); // for Firefox, fails silently on others
    this.target.addEventListener('mousewheel', this.onZoom.bind(this), false);     // For others, fails silently on FF
    document.onkeydown = this.onKeyPress.bind(this);
};
/**
 * onMouseMove event handler mouse cursor movement
 * orthographic camera views.
 * @private
 * @param {type} e
 */
CameraCrew.prototype.onMouseMove = function (e) {

//  this.settings['mouse']['x']=e.x;
//  this.settings['mouse']['y']=e.y;    
};
/**
 * onMouseClick event handler mouse clicks
 * orthographic camera views.
 * @private
 * @param {type} e
 */
CameraCrew.prototype.onMouseClick = function (e) {

//  this.settings['mouse']['x']=e.x;
//  this.settings['mouse']['y']=e.y;    
};
/**
 * onKeyPress event handler for arrow keys, intended for panning with
 * orthographic camera views.
 * @private
 * @param {type} e
 * @returns {undefined}
 */
CameraCrew.prototype.onKeyPress = function (e) {
    //if (this.cameraType !== CameraCrew.PRESPECTIVE) {
    console.log("key event", e.keyCode)
    switch (e.keyCode) {
        case 37:
            this.oOffsetX += .01;
            e.preventDefault();
            break;
        case 38:
            this.oOffsetY += .01;
            e.preventDefault();
            break;
        case 39:
            this.oOffsetX -= .01;
            e.preventDefault();
            break;
        case 40:
            this.oOffsetY -= .01;
            e.preventDefault();
            break;
    }
    this.setSize(this.target.clientWidth, this.target.clientHeight, this.rx, this.ry);
    requestAnimationFrame(this.animate.bind(this));
    //}
};
/**
 * onZoom, event handler for zoom(mouse wheel) events
 * @private
 * @returns {undefined}
 */
CameraCrew.prototype.onZoom = function (e) {

    if (this.cameraType === CameraCrew.PRESPECTIVE) {
        if (this.afRequest === -1) {
            this.startAnimation();
        }
        window.clearTimeout(this.lastZoom);
        this.lastZoom = window.setTimeout(this.stopAnimation.bind(this), 300);
    }
    else {
        var wDelta = e.wheelDelta &lt; 0 ? 0.004 : -0.004;
        this.oRange += wDelta;
        if (this.oRange &lt; 0.02)
            this.oRange = 0.02;
        this.setSize(this.target.clientWidth, this.target.clientHeight, this.rx, this.ry);
        if (this.afRequest === -1) {
            this.startAnimation();
        }
        window.clearTimeout(this.lastZoom);
        this.lastZoom = window.setTimeout(this.stopAnimation.bind(this), 300);
    }

};
/**
 * startAnimation, starts animation mode. Normally only private use
 * @this{CameraCrew}
 * @returns {undefined}
 */
CameraCrew.prototype.startAnimation = function () {
    console.log("animation start");
//    this.depth_samples = this.settings['enhancement']['DepthSamples'];
//    this.settings['enhancement']['DepthSamples'] = this.DPSANIM;
//    this.updateShader();
    this.afRequest = requestAnimationFrame(this.animate.bind(this));
//    this.setSize(this.target.clientWidth, this.target.clientHeight, 2, 2);
};
/** 
 * stopAnimation, stops the animation by canceling last frame.
 * Normally only private use.
 * @this{CameraCrew}
 * @returns {undefined}
 */
CameraCrew.prototype.stopAnimation = function () {
//    this.setSize(this.target.clientWidth, this.target.clientHeight, 1, 1);

    if (this.depth_samples) {
        console.log("animation stop", this.depth_samples);
        this.settings['enhancement']['DepthSamples'] = this.depth_samples;
    }
    window.cancelAnimationFrame(this.afRequest);
    this.updateShader();
    this.afRequest = -1;
};
/**
 * animate, Frame rate limited animation frame request loop
 * @private
 * @this{CameraCrew}
 * @param {dateTime} tstamp last render time 
 * @returns {undefined}
 */
CameraCrew.prototype.animate = function (tstamp) {
    if (tstamp - this.lastRender > 1000 / this.FPS) {
        this.lastRender = tstamp;
        this.controls.update();
        this.render();
    }
    if (this.afRequest !== -1) {
        this.afRequest = requestAnimationFrame(this.animate.bind(this));
    }
};
/**
 * render Callback. Set this to the render function
 * of your RayCaster instance, to get automatic render updates when the camera
 * view is updated.
 * @callback CameraCrew~render
 */
CameraCrew.prototype.render = function () {

};

/**
 * updateShader Callback. To provide smoother camera interaction, the depth sample setting
 * can be automatically modified to a lower value during camera rotation and zoom.
 * Set this to the updateShader function of your RayCaster instance, to allow 
 * the shader to be updated with the modified depth sample values
 * @callback CameraCrew~updateShader 
 * @returns {undefined}
 */
CameraCrew.prototype.updateShader = function () {

};
window['CameraCrew'] = CameraCrew;
CameraCrew.prototype['selectCamera'] = CameraCrew.prototype.selectCamera;
CameraCrew.prototype['setupMouseEvents'] = CameraCrew.prototype.setupMouseEvents;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Modules</h3><ul><li><a href="module-dependency.html">dependency</a></li></ul><h3>Classes</h3><ul><li><a href="CameraCrew.html">CameraCrew</a></li><li><a href="ColorMap.html">ColorMap</a></li><li><a href="GeneralDataLoader.html">GeneralDataLoader</a></li><li><a href="leaf.html">leaf</a></li><li><a href="NativeImageLoader.html">NativeImageLoader</a></li><li><a href="OpenRayCaster.html">OpenRayCaster</a></li><li><a href="OpenVolumeData.html">OpenVolumeData</a></li><li><a href="PointDataLoader.html">PointDataLoader</a></li><li><a href="RayTracingPass.html">RayTracingPass</a></li><li><a href="RenderPass.html">RenderPass</a></li><li><a href="TestHarness.html">TestHarness</a></li><li><a href="THREE.OrbitControls.html">OrbitControls</a></li><li><a href="VolDataLoader.html">VolDataLoader</a></li><li><a href="VolumeEgressCoordinatePass.html">VolumeEgressCoordinatePass</a></li><li><a href="VolumeGeometry.html">VolumeGeometry</a></li><li><a href="VolumeIngressCoordinatePass.html">VolumeIngressCoordinatePass</a></li></ul><h3>Namespaces</h3><ul><li><a href="Colormaps.html">Colormaps</a></li><li><a href="MissingMath.html">MissingMath</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.2.2</a> on Tue Sep 20 2016 13:34:34 GMT+0900 (JST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
